using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Text;

namespace GalArc.Generator;

[Generator]
internal class ViewLocatorGenerator : IIncrementalGenerator
{
    private const string ViewLocatorBaseName = "GalArc";
    private const string ArcOptionsBaseName = "GalArc.Models.Formats.Commons";
    private const string ArcOptionsFullName = "GalArc.Models.Formats.Commons.ArcOptions";
    private const string SettingOptionsBaseName = "GalArc.Infrastructure.Settings";
    private const string SettingOptionsFullName = "GalArc.Infrastructure.Settings.SettingOptions";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<INamedTypeSymbol> classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is ClassDeclarationSyntax c && c.BaseList is not null,
                transform: static (ctx, _) =>
                {
                    ClassDeclarationSyntax classDeclaration = (ClassDeclarationSyntax)ctx.Node;
                    return ctx.SemanticModel.GetDeclaredSymbol(classDeclaration) is INamedTypeSymbol symbol ? symbol : null;
                })
            .Where(static m => m is not null)!;

        IncrementalValuesProvider<INamedTypeSymbol> foundImplementations = classDeclarations
            .Where(classSymbol =>
            {
                if (classSymbol.IsAbstract)
                    return false;

                INamedTypeSymbol baseType = classSymbol.BaseType;
                while (baseType != null)
                {
                    string display = baseType.ToDisplayString();
                    if (display == ArcOptionsFullName || display == SettingOptionsFullName)
                    {
                        return true;
                    }
                    baseType = baseType.BaseType;
                }
                return false;
            });

        IncrementalValueProvider<ImmutableArray<INamedTypeSymbol>> collected = foundImplementations.Collect();

        context.RegisterSourceOutput(collected, (spc, source) =>
        {
            if (source.IsDefaultOrEmpty)
            {
                return;
            }

            ImmutableArray<string> classNames = [.. source.Select(s => s.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))];

            string sourceCode = GenerateSource(classNames);
            spc.AddSource("ViewLocator.g.cs", sourceCode);
        });
    }

    private static string GenerateSource(ImmutableArray<string> options)
    {
        StringBuilder sb = new();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine();
        sb.AppendLine("using Avalonia.Controls;");
        sb.AppendLine("using Avalonia.Controls.Templates;");
        sb.AppendLine($"using {ArcOptionsBaseName};");
        sb.AppendLine($"using {SettingOptionsBaseName};");
        sb.AppendLine();
        sb.AppendLine($"namespace {ViewLocatorBaseName}");
        sb.AppendLine("{");
        sb.AppendLine("    internal sealed partial class ViewLocator : IDataTemplate");
        sb.AppendLine("    {");
        sb.AppendLine("        public Control Build(object param)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (param is ArcOptions arcOptions)");
        sb.AppendLine("                return BuildArcOptions(arcOptions);");
        sb.AppendLine("            else if (param is SettingOptions settingOptions)");
        sb.AppendLine("                return BuildSettingOptions(settingOptions);");
        sb.AppendLine("            else");
        sb.AppendLine("                return new TextBlock { Text = \"Not Found: \" + param?.GetType().FullName };");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        private Control BuildArcOptions(ArcOptions param)");
        sb.AppendLine("        {");
        sb.AppendLine("            return param switch");
        sb.AppendLine("            {");
        foreach (string option in options)
        {
            if (!option.Contains("ViewModels"))
                sb.AppendLine($"                {option} => new {option.Replace("Options", "Widget")}(),");
        }
        sb.AppendLine("                _ => new TextBlock { Text = \"Not Found: \" + param?.GetType().FullName }");
        sb.AppendLine("            };");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        private Control BuildSettingOptions(SettingOptions param)");
        sb.AppendLine("        {");
        sb.AppendLine("            return param switch");
        sb.AppendLine("            {");
        foreach (string option in options)
        {
            if (option.Contains("ViewModels"))
                sb.AppendLine($"                {option} => new {option.Replace("ViewModels", "Views").Replace("Options", "Widget")}(),");
        }
        sb.AppendLine("                _ => new TextBlock { Text = \"Not Found: \" + param?.GetType().FullName }");
        sb.AppendLine("            };");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }
}
